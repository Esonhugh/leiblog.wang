---
top: 8
title: 千兆以太网视频传输
categories:
  - Technical
tags:
  - FPGA
  - Ethernet
date: 2020-07-19 17:15:34
---

![Banner](http://leiblog.wang/static/image/2020/7/swedishfishing.jpg)

我接触到的每一块FPGA Evaluation Board上都配有以太网口，于是我总觉得以太网的协议一定要学。

加上疫情，学校的实验室居然不开！现在迫切的想验证一些图像算法，我可不想在狭隘的宿舍空间里给FPGA再接一块VGA/HDMI接口的显示器。于是，这是一篇探索利用以太网传输视频讯号，通过PC机来显示的文章。

本文使用的是ZYNQ器件，事实上，使用纯Verilog实现的以太网传输视频网上也找到了一些demo，这应该是因为UDP传输使用Verilog更高效（不一定，但Verilog写TCP协议的至今都没有能普遍商用的解决方案），因为我使用的是ZYNQ器件，准确的说是`PYNQ-Z2`,以太网口在PS端，没法套用那些工程，于是就有了挖坑、踩坑、填坑的过程，就有了这篇博客，就有了新的Github的仓库。

Github Page: https://github.com/LeiWang1999/EthernetVideo

**PS：求Follow、Star、PR！QAQ**

<!-- more -->

## 1. Tips Before Experiment

推荐阅读[UG 585](https://www.xilinx.com/support/documentation/user_guides/ug585-Zynq-7000-TRM.pdf)，这是官方提供的，最为详实的ZYNQ器件教学文档，其中有关以太网的驱动以及Vivado SDK提供的几个有关lwip的Template说明都可以在**Chapter 16 Gigabit Ethernet Controller**找到。

![Chapter16](http://leiblog.wang/static/image/2020/7/fc6aDJ.png)

其实国内的相关教程，基本都是翻译的Xilinx的文档，毕竟如果不看这个文档，编写Arm端程序的时候根本无从下手，比如我应该导入哪个库，如何初始化等等。

另外，因为我曾经自学过计算机网络，所以对于UDP、TCP、IPV4、IPV6这些关键词并不陌生，如果你不清楚或许你应该去补一下计算机网络的知识。

### What is UDP/TCP

TCP/IP协议集包括应用层,传输层，网络层，网络访问层。

##### 其中应用层包括:

1、超文本传输协议（HTTP）:万维网的基本协议；
2、文件传输（TFTP简单文件传输协议）；
3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；
4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；
5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。

##### 其次网络层包括:

1、Internet协议（IP）；
2、Internet控制信息协议（ICMP）；
3、地址解析协议（ARP）；
4、反向地址解析协议（RARP）。

##### 网络访问层:

网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射， 以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接. 当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程， 但我相信每位学习软件开发的同学都有必要去仔细了解一番。

#### 下面着重讲解一下TCP协议和UDP协议的区别

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程：

1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；

2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；

3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。

#### TCP三次握手过程

第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

**3次握手的特点**：没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。

TCP建立连接要进行3次握手，而断开连接要进行4次

第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。

#### 名词解释

1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

2、SYN 同步序列号，TCP建立连接时将这个位置1。

3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

#### TCP的包头结构：

源端口 16位；目标端口 16位；序列号 32位；回应序号 32位；TCP头长度 4位；reserved 6位；控制代码 6位；窗口大小 16位；偏移量 16位；校验和 16位；选项 32位(可选)；

这样我们得出了TCP包头的最小长度，为20字节。

#### UDP（User Data Protocol，用户数据报协议）

1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。

5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。

我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

**ping命令**是用来探测主机到主机之间是否可通信，如果不能**ping**到某台主机，表明不能和这台主机建立连接。**ping命令**是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。

ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。

#### UDP的包头结构

源端口 16位；目的端口 16位；长度 16位；校验和 16位

#### 小结TCP与UDP的区别

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

### What is IPV4/IPV6

IPv6和IPv4，都是给网络中的主机编址的一种方式。

网络数据要从一个主机传送到另外一个主机，就像把快递从北京送到石家庄，你得有地址。而IPv4，或者IPv6，解决的就是这个网络空间的编织问题。

**那么IPv6是什么？**

是接入网络的一台主机的网络地址。准确地说，是给主机编址的一种方式。

**IPv4和IPv6有什么不一样？**

IPv4用32位的二进制位来表示一台主机的网络地址；而IPv6用128位二进制位来表示一台主机的网络地址。

我们日常看到的8.8.8.8这样的地址，只是一种便于人类记忆和观察的表示方式而已，8.8.8.8的实际地址表示成二进制应该是00000100000001000000010000000100

IPv6也有更便于人类记忆和观察的表示方式，比如2001:fecd:ba23:cd1f:dcb1:1010:9234:4088，但在计算机网络中，它的实际地址仍然是一个二进制。

显而易见，无论是32位的网络地址，还是128位的网络地址，其能够提供的地址个数都是可数的，有上限的。32位的IPv4地址，大约能提供43亿个设备接入互联网，当初设计IP协议的人觉得，43亿还不够你们玩？结果我们看到了，确实不够玩。所以IPv6作为一个能提供更多可用地址的协议被设计出来了，那么128位的IPv6，能提供多少地址呢？

太多了。超过了宇宙中原子数量的总和（作为参考，宇宙中原子数的总和大概是10^80这个数量级，而IPv6提供的是10^124这个数量级），因此，IPv6从理论上讲，是不可能用尽的。

关于计算机位数，我一直很喜欢一段超级浪漫的话，大概所有的指数级增长都适用这句话：

在用32位二进制数表示时间戳的计算机上，2038年这个时间戳将会溢出。但在用64位二进制数表示时间戳的计算机上，当这个二进制数溢出时，那大概是2920亿年。到那时，位于猎户座旋臂的太阳，已经是黑矮星或暗黑物质，猎户座旋臂已经被重力波震断，银河系大概则已经变成小型似星体了。

数学的魔力，指数的魔力。

**从「IPv4」过渡到「IPv6」需要哪些准备工作？**

其实我们一直在做各种准备工作了。

1. 在IPv6全面铺开之前，通过一些方式延缓IPv4耗尽的速度。

按照互联网发展的实际速度，接入互联网的主机越来越多，早已超过了IPv4的容纳极限。为了延缓IPv4耗尽的速度，为IPv6的建设争取时间，互联网早都应用了NAT技术，通过多层接入的方式，把一个公网IP地址共享给好几台设备使用。这样一个家庭或者一个组织，内部可能接入了很多主机，但其在公网上的地址是一样的。公网地址就类似于：北京市海淀区清华大学，紫荆公寓6号楼。而楼里还有125、225宿舍，宿舍还有床位。这样很多主机接入了互联网，但共享一个IP地址

2. 通过隧道技术将IPv6和IPv4结合起来。

现在网络寻址的方式建立在IPv4之上，IPv6还没有完全普及。那么在这个普及的过程中，显然会有长期的IPv4和IPv6共存的阶段。那可能会出现这样的一种情况：现阶段，使用IPv6的两个区域网络之间，并没有能支持IPv6的路由来连接，等IPv6逐渐普及，IPv4网络萎缩，这时候使用IPv4的两个区域网络之间，并没有能支持IPv4的路由来连接。在这种情况下，科学家又创造性地提出了隧道技术，也就是说，在第一种情况下，用IPv4的格式把IPv6格式的数据包再包装一层，使用IPv4的协议寻址，让他能通过IPv4路由网络，从一个IPv6区域网络到另外一个IPv6区域网络，到达之后再把外面那层包装拆掉，在区域网络中通过IPv6寻址；在第二种情况下反过来，用IPv6的格式把IPv4格式的数据包再包装一层，使用IPv6的协议寻址，让他能通过IPv6路由网络，从一个IPv4区域网络到另外一个IPv4区域网络，到达之后再把外面那层包装拆掉，在区域网络中通过IPv4寻址。

3. 逐步更新网络路由节点，使其可以使用IPv6的方式寻址。

直到彻底替代IPv4，这个需要多少年呢？需要很多很多年吧。等我们都老去了，离去了，这个过程也未必能完全结束。

### What is lwip

不能再讲计算机网络的原理了，让我们的文章回归正轨，我们要开始讲一些工程相关的知识。

互联网技术非常灵活，能够适应过去几十年不断变化的网络环境。互联网技术虽然最初是为阿帕网（ARPANET）等低速网络开发的，但现在可以在一个很大的链路技术频谱上运行，在带宽和误码率方面由截然不同的特性。由于现在已经开发了大量使用互联网技术的应用程序，能在未来的无线网络中使用现有的互联网技术是非常有利的。诸如传感器之类的小型设备通常需要体积小且价格便宜，因此不得不在有限的计算资源和内存上实现互联网协议。

lwIP最早由Adam Dunkels编写，目前由Kieran Mansley带领的团队开发（开发者主页http://savannah.nongnu.org/projects/lwip ）。lwIP是一个小型TCP/IP栈，可以在嵌入式系统中使用。lwIP采取模块化设计，核心栈是IP协议的实现，用户可以在其上选择添加TCP、UDP、DHCP等其它协议，包括这些协议的各种特性。当然这样会导致代码量增加、复杂性提高，需要根据用户的需求进行调整。此外，lwIP在有无操作系统、支持或不支持线程的情况下都可以运行，适用于8位或32位微处理器，支持小端和大端系统。

**总而言之，lwip是一个库，支持了多种网络协议，包括ARP、TCP、UDP**。

而操作lwip库，可以使用**RAW API**和**socket API**两种API。

顾名思义，RAW API的操作更原始，效率高，socket API的封装层次更高，更好用。

## 2. Ethernet Toturial

首先设计硬件环境，打开Vivado，新建一个BlockDesign，把ZYNQ添加进工程。

在ZYNQ配置界面，配置以太网接口，我们使用MIO来驱动以太网。

![ZYNQ_CONFIG](http://leiblog.wang/static/image/2020/7/ZYNQ_config.png)

{% colorquote info %}

其实你可以下载我预先保存好的tcl配置文件，在Preset选项里选择导入，下载地址：http://leiblog.wang/static/FPGA/Easy_Simple_pynq_z2.tcl

{% endcolorquote %}

然后点击自动布线，连接上Clock，如下图

![BlockDesign](http://leiblog.wang/static/image/2020/7/BlockDesign.png)

配置完成之后、综合、布线、生成bit、Export Hardware、Launch SDK。

### Example 00 udp_helloworld

这里我们写以太网的工程有很多选择，一种是从头到尾自己配置UDP等，第二种是选择SDK内置的几个Template，主要包括TCP回传，TCP/UDP的Server/Client端。我们使用第一种，因为第二种，实在是不利于后期的封装，代码龙飞凤舞，因为main函数里塞了太多的东西了，并且我们一般只会用到ipv4，感兴趣的网友可以自己去体验一下:)，验证一下以太网回传等。

于是，我们以默认的`Helloword`模版新建一个工程，第一个实验名是用UDP协议向PC发送"Hello World!"，所以取名叫udp_helloworld。

但是默认的bsp里是没有加入lwip库的，我们在system.mss文件里选择Modify this BSP's Settings，添加lwip的依赖。

![Add LWIP Lib](http://leiblog.wang/static/image/2020/7/add_lwip_lib.png)

然后，在把以下代码拖入工程的src里，https://github.com/LeiWang1999/EthernetVideo/tree/master/example/00_udp_helloworld

然后File->Refresh. 确保没有Error。

**如果碰到了找不到lwip_init的定义错误，尝试右击udp_helloworld,在ARM_GCC_LINKER 里加入lwip4**

![Add Lwip 4](http://leiblog.wang/static/image/2020/7/add_lib.png)

如果没有错误，把ZYNQ的以太网口用网线和PC连接到一起，就可以烧录程序了。

在我提供的程序里，ZYNQ的配置的网络信息如下：

IP:192.168.1.100, netmask:255.255.255.0, gateway:192.168.1.1

UDP连接的PC的配置如下：

IP:192.168.1.200,netmask:255.255.255.0, gateway:192.168.1.1

所以，我们需要给我们的以太网设置一下静态ip

![config ip](http://leiblog.wang/static/image/2020/7/config_ip.png)

然后，烧录程序，打开网络调试助手(网上随便下载的)，注意这里不要挂vpn，不然可能会翻车（不要问我怎么知道的

![HelloWorld Result](http://leiblog.wang/static/image/2020/7/hello_world_result.png)

每隔一段时间，ZYNQ给PC发送“Hello World”，**well done!**

#### 分析程序

其实都是套路，搬砖就完事了，但凡使用lwIP的程序，无论TCP还是UDP，在进入while(1)循环前，都会有这样一个配置流程：

- 设置开发板MAC地址
- 开启中断系统
- 设置本地IP地址
- 初始化lwIP
- 添加网络接口
- 设置默认网络接口
- 启动网络
- 初始化TCP或UDP连接（自定义函数）

在while(1)循环中，第一件事必然是使用xemacif_input函数将MAC队列中的包传输到lwIP栈中，这是Xilinx适配器提供的函数。再之后才是用户代码。我们继续看UDP相关文件中是如何进行连接初始化和“Hello World”字符输出的。

lwip库中的函数很多都会返回执行状态码，也就是错误码，如果没有错误会返回ERR_OK,在"lwip/err.h"中定义了各种错误码。

```c++
err = udp_send(tpcb, pbuf_to_be_sent);
	if (err != ERR_OK) {
		xil_printf("Error on udp send : %d\r\n", err);
		return;
	}
```

memset和memcpy这两个函数来自string.h。这是两个经典的C语言中的内存操作函数。memset函数是将某一块内存中的内容全部设置为指定的值，通常为新申请的内存做初始化操作。其原型如下，将s中当前位置后面的n个字节用ch替换，memcpy函数用于内存拷贝，其原型如下，在src所指的内存地址的起始位置开始，拷贝n个字节到目标dest所指内存地址的起始位置中。

剩下的配置请仔细阅读代码与Xilinx的文档！

### Reference

1. https://www.zhihu.com/question/358209123
2. https://zhuanlan.zhihu.com/p/24860273
3. https://blog.csdn.net/FPGADesigner